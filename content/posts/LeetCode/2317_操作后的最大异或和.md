---
title: 操作后的最大异或和
date: 2022-07-02T11:43:00+08:00
description: 操作后的最大异或和
menu:
  sidebar:
    name: 2317_操作后的最大异或和
    identifier: LeetCode-2317_操作后的最大异或和
    parent: LeetCode
    weight: 2317
hero: /images/LeetCode.png
---

## 题目
难度：**中等**

### 描述
> 给你一个下标从`0`开始的整数数组`nums`。一次操作中，选择**任意**非负整数`x`和一个下标`i`，更新`nums[i]`为`nums[i] AND (nums[i] XOR x)`。
>
> 注意，`AND`是逐位与运算，`XOR`是逐位异或运算。
>
> 请你执行**任意次**更新操作，并返回`nums`中所有元素**最大**逐位异或和。

### 示例
示例 1:
>  输入：nums = [3,2,4,6]
>
>  输出：7
>
>  解释：选择 x = 4 和 i = 3 进行操作，num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2 。
>
>  现在，nums = [3, 2, 4, 2] 且所有元素逐位异或得到 3 XOR 2 XOR 4 XOR 2 = 7 。
>
>  可知 7 是能得到的最大逐位异或和。
>
>  注意，其他操作可能也能得到逐位异或和 7 。

示例 2：
>  输入：nums = [1,2,3,9,2]
>
>  输出：11
>
>  解释：执行 0 次操作。
>
>  所有元素的逐位异或和为 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11 。
>
>  可知 11 是能得到的最大逐位异或和。

## 解题思路
题目是求数组中所有元素**逐位异或和**后的最大值，逐位异或的真值表[如下](#逐位异或真值表)所示。可以看到：
- 如果数组中所有元素在某个bit位都是0，那在逐位异或和中对应的bit位也**只能是**0.
- 如果数组中所有元素在某个bit位有**偶数**个1，那在逐位异或和中对应的bit位也为0.
- 如果数组中所有元素在某个bit位有**奇数**个1，那在逐位异或和中对应的bit位为1.

题目中提供了一个更新操作：更新`nums[i]`为`nums[i] AND (nums[i] XOR x)`。

注意到其采用的是`AND 按位与`的方式，也就是说，如果元素的某个bit为`0`，则无论采用何种更新操作，对应bit也只能保持为`0`，无法转变为`1`。

相反，如果元素的某个bit为`1`，假如我们可以构造对应bit为`0`的另外一个元素，则可以在按位与后将其转变为0。题目说，`X`是任意选择的一个非负整数，因此可以容易的通过选择合适的`X`在经过`nums[i] XOR x`后实现此目的。

### 总结
**目标：** 为使得结果值最大，应尽可能使得值为`1`的bit多。

如上述分析:
- 如果在所有数组元素中，某个bit全部为`0`，则最终结果值相应bit只能为0。
- 如果在所有数组元素中，某个bit有出现过`1`，则有方案可以使得在经过更新操作后，仅有奇数个元素在该bit上为`1`。因此，可以使得最终结果相应bit保持为`1`。

**所以：** 如果元素中某个bit为1，则最终结果该bit就为1；对应的解法就是将数组中所有元素按位或。

### 逐位异或真值表
<style>
table th:first-of-type {
    width: 5cm;
}
table th:nth-of-type(2) {
    width: 5cm;
}
table th:nth-of-type(3) {
    width: 5cm;
}
</style>
| a ^ b 	| 0 	| 1 	|
|:-----:	|:-:	|:-:	|
|   0   	| 0 	| 1 	|
|   1   	| 1 	| 0 	|

## 我的题解
```Java
class Solution {
    public int maximumXOR(int[] nums) {
        int ans = 0;
        for (int num : nums) {
            ans |= num;
        }

        return ans;
    }
}
```

## 题目链接
https://leetcode.cn/problems/maximum-xor-after-operations/
