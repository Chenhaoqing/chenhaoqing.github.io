<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode on Chenhaoqing's Blog</title><link>https://chenhaoqing.github.io/posts/leetcode/</link><description>Recent content in LeetCode on Chenhaoqing's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 02 Jul 2022 11:43:00 +0800</lastBuildDate><atom:link href="https://chenhaoqing.github.io/posts/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>操作后的最大异或和</title><link>https://chenhaoqing.github.io/posts/leetcode/2317_%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/</link><pubDate>Sat, 02 Jul 2022 11:43:00 +0800</pubDate><guid>https://chenhaoqing.github.io/posts/leetcode/2317_%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/</guid><description>题目 难度：中等
描述 给你一个下标从0开始的整数数组nums。一次操作中，选择任意非负整数x和一个下标i，更新nums[i]为nums[i] AND (nums[i] XOR x)。
注意，AND是逐位与运算，XOR是逐位异或运算。
请你执行任意次更新操作，并返回nums中所有元素最大逐位异或和。
示例 示例 1:
输入：nums = [3,2,4,6]
输出：7
解释：选择 x = 4 和 i = 3 进行操作，num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2 。
现在，nums = [3, 2, 4, 2] 且所有元素逐位异或得到 3 XOR 2 XOR 4 XOR 2 = 7 。
可知 7 是能得到的最大逐位异或和。
注意，其他操作可能也能得到逐位异或和 7 。
示例 2：
输入：nums = [1,2,3,9,2]</description></item><item><title>一维数组的动态和</title><link>https://chenhaoqing.github.io/posts/leetcode/1480_%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</link><pubDate>Sat, 02 Jul 2022 10:59:00 +0800</pubDate><guid>https://chenhaoqing.github.io/posts/leetcode/1480_%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</guid><description>题目 难度：简单
描述 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。 请返回 nums 的动态和。 示例 示例 1： 输入：nums = [1,2,3,4] 输出：[1,3,6,10] 解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2： 输入：nums = [1,1,1,1,1] 输出：[1,2,3,4,5] 解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3： 输入：nums = [3,1,2,10,1] 输出：[3,4,6,16,17] 我的题解 class Solution { public int[] runningSum(int[] nums) { int[] sums = new int[nums.length]; sums[0] = nums[0]; for (int i = 1; i &amp;lt; nums.</description></item></channel></rss>