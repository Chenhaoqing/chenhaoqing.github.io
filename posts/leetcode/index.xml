<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode on Chenhaoqing's Blog</title><link>https://chenhaoqing.github.io/posts/leetcode/</link><description>Recent content in LeetCode on Chenhaoqing's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 02 Nov 2022 22:13:00 +0800</lastBuildDate><atom:link href="https://chenhaoqing.github.io/posts/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>删除有序数组中的重复项</title><link>https://chenhaoqing.github.io/posts/leetcode/26_%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link><pubDate>Wed, 02 Nov 2022 22:13:00 +0800</pubDate><guid>https://chenhaoqing.github.io/posts/leetcode/26_%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid><description>题目 难度：简单
描述 给你一个升序排列的数组nums，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。
由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有k个元素，那么nums的前k个元素应该保存最终结果。
将最终结果插入nums的前k个位置后返回k。
不要使用额外的空间，你必须在原地修改输入数组,并在使用 O(1) 额外空间的条件下完成。
示例 示例 1:
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
解题思路 由于输入的是升序数组，通过比较双指针P与Q所指向的值是否相同
若相同，则移动Q指针 若不同，则将Q的值填入到P+1的位置 因为是升序数组，Q必定已遍历过P+1的位置，且由于与P或之前的元素值重复 我的题解 class Solution { public int removeDuplicates(int[] nums) { int smooth = 0; int fast = smooth + 1; while (fast &amp;lt; nums.</description></item><item><title>最大层内元素和</title><link>https://chenhaoqing.github.io/posts/leetcode/1161_%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C/</link><pubDate>Sun, 31 Jul 2022 22:41:00 +0800</pubDate><guid>https://chenhaoqing.github.io/posts/leetcode/1161_%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C/</guid><description>题目 难度：中等
描述 给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。
请返回层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。
示例 示例 1:
输入：root = [1,7,0,7,-8,null,null]
输出：2
解释：
第 1 层各元素之和为 1，
第 2 层各元素之和为 7 + 0 = 7，
第 3 层各元素之和为 7 + -8 = -1，
所以我们返回第 2 层的层号，它的层内元素之和最大。
解题思路 利用深度优先搜索的思路遍历二叉树，在遍历的过程中借助数组sums存储各层的和，数组的下标即为层号 - 1（因为题目层号从1开始）。遍历二叉树后，在sums中找到最大值对应的下标。 注意，因为题目要找层号最小的，所以在找sums最大值时要使用&amp;gt;而不是&amp;gt;=。
我的题解 class Solution { private List&amp;lt;Integer&amp;gt; sums = new ArrayList&amp;lt;&amp;gt;(); public int maxLevelSum(TreeNode root) { traverse(root, 0); int minLvl = 0; for (int lvl = 0; lvl &amp;lt; sums.</description></item><item><title>猜数字大小</title><link>https://chenhaoqing.github.io/posts/leetcode/374_%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/</link><pubDate>Sat, 16 Jul 2022 00:10:00 +0800</pubDate><guid>https://chenhaoqing.github.io/posts/leetcode/374_%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/</guid><description>题目 难度：简单
描述 猜数字游戏的规则如下：
每轮游戏，我都会从1到n随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。 你可以通过调用一个预先定义好的接口int guess(int num)来获取猜测结果，返回值一共有3种可能的情况（-1，1或0）：
-1：我选出的数字比你猜的数字小 pick &amp;lt; num 1：我选出的数字比你猜的数字大 pick &amp;gt; num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num 返回我选出的数字。 示例 示例 1:
输入：n = 10, pick = 6
输出：6
示例 2：
输入：n = 1, pick = 1
输出：1
解题思路 通过二分查找不断缩减范围，直至找到最终结果。
关键点 一开始提交的为下面的版本，多个用例都出现超出时间限制。
public class Solution extends GuessGame { public int guessNumber(int n) { int left = 1; int right = n; while (left &amp;lt; right) { int mid = (right + left) / 2; if (guess(mid) == -1) { right = mid - 1; } else if (guess(mid) == 1) { left = mid + 1; } else { return mid; } } return left; } } 参考了官方题解后发觉，(right + left)可能会导致超出int的范围，需要转换为left + (right - left)。</description></item><item><title>每日温度</title><link>https://chenhaoqing.github.io/posts/leetcode/739_%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</link><pubDate>Sun, 03 Jul 2022 23:43:00 +0800</pubDate><guid>https://chenhaoqing.github.io/posts/leetcode/739_%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</guid><description>题目 难度：中等
描述 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。
示例 示例 1:
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
示例 2：
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
示例 3:
输入: temperatures = [30,60,90]
输出: [1,1,0]
解题思路 暴力法 题目是求下一个更高温度是出现在几天后；因此，针对数组中的每一个元素，遍历其之后的所有元素，找到第一个比其更高的温度后，两者的数组下标差值即为答案。
单调栈 可以观察得知，假如有元素从左到右为A-&amp;gt;B-&amp;gt;C。如果C的值比B小，则C必不可能为比A值大的第一个元素（因为在其左边的B也会比A值大）。因此，在遍历数组的过程中，可以利用此特性，借用栈实现单调递减栈，减少比较的次数。
具体实现方式为：将新遍历到的数组元素A与栈顶元素B（栈中实际存储数组的下标，比较时需要转换为数组中的实际元素值）做大小比较。
如果A &amp;gt; B的大，则表明A为比B值更大的第一个元素；求两者的数组下标差值即可。并将B出栈，持续比较A与B的大小关系，直到栈为空或者A &amp;lt;= B为止 如果A &amp;lt;= B，则表明还未找到比B大的第一个元素，需要将A入栈，遍历下一个数组元素 我的题解 暴力法 class Solution { public int[] dailyTemperatures(int[] temperatures) { int[] ans = new int[temperatures.length]; for (int i = 0; i &amp;lt; temperatures.</description></item><item><title>操作后的最大异或和</title><link>https://chenhaoqing.github.io/posts/leetcode/2317_%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/</link><pubDate>Sat, 02 Jul 2022 11:43:00 +0800</pubDate><guid>https://chenhaoqing.github.io/posts/leetcode/2317_%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/</guid><description>题目 难度：中等
描述 给你一个下标从0开始的整数数组nums。一次操作中，选择任意非负整数x和一个下标i，更新nums[i]为nums[i] AND (nums[i] XOR x)。
注意，AND是逐位与运算，XOR是逐位异或运算。
请你执行任意次更新操作，并返回nums中所有元素最大逐位异或和。
示例 示例 1:
输入：nums = [3,2,4,6]
输出：7
解释：选择 x = 4 和 i = 3 进行操作，num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2 。
现在，nums = [3, 2, 4, 2] 且所有元素逐位异或得到 3 XOR 2 XOR 4 XOR 2 = 7 。
可知 7 是能得到的最大逐位异或和。
注意，其他操作可能也能得到逐位异或和 7 。
示例 2：
输入：nums = [1,2,3,9,2]
输出：11
解释：执行 0 次操作。</description></item><item><title>一维数组的动态和</title><link>https://chenhaoqing.github.io/posts/leetcode/1480_%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</link><pubDate>Sat, 02 Jul 2022 10:59:00 +0800</pubDate><guid>https://chenhaoqing.github.io/posts/leetcode/1480_%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</guid><description>题目 难度：简单
描述 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。
请返回 nums 的动态和。
示例 示例 1：
输入：nums = [1,2,3,4]
输出：[1,3,6,10]
解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。
示例 2：
输入：nums = [1,1,1,1,1]
输出：[1,2,3,4,5]
解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。
示例 3：
输入：nums = [3,1,2,10,1]
输出：[3,4,6,16,17]
我的题解 class Solution { public int[] runningSum(int[] nums) { int[] sums = new int[nums.length]; sums[0] = nums[0]; for (int i = 1; i &amp;lt; nums.length; i++) { sums[i] = sums[i - 1] + nums[i]; } return sums; } } 题目链接 https://leetcode.</description></item></channel></rss>