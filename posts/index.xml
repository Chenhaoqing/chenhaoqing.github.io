<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Chenhaoqing's Blog</title><link>https://chenhaoqing.github.io/posts/</link><description>Recent content in Posts on Chenhaoqing's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 02 Jul 2022 10:59:00 +0800</lastBuildDate><atom:link href="https://chenhaoqing.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>一维数组的动态和</title><link>https://chenhaoqing.github.io/posts/leetcode/1480_%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</link><pubDate>Sat, 02 Jul 2022 10:59:00 +0800</pubDate><guid>https://chenhaoqing.github.io/posts/leetcode/1480_%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</guid><description>题目 难度：简单
描述 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。 请返回 nums 的动态和。 示例 示例 1： 输入：nums = [1,2,3,4] 输出：[1,3,6,10] 解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2： 输入：nums = [1,1,1,1,1] 输出：[1,2,3,4,5] 解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3： 输入：nums = [3,1,2,10,1] 输出：[3,4,6,16,17] 我的题解 class Solution { public int[] runningSum(int[] nums) { int[] sums = new int[nums.length]; sums[0] = nums[0]; for (int i = 1; i &amp;lt; nums.</description></item><item><title>对象的存储位置</title><link>https://chenhaoqing.github.io/posts/onjava/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/</link><pubDate>Thu, 09 Jun 2022 00:26:32 +0800</pubDate><guid>https://chenhaoqing.github.io/posts/onjava/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/</guid><description>数据存储的位置 常见共有如下5种数据存储的方式：
寄存器，数据保存在中央处理器（即CPU），数量有限，速度最快；在Java中无法直接控制寄存器的分配；C和C++允许程序向编译器申请分配寄存器。 栈，数据存储在RAM里，处理器可以通过栈指针直接操作数据。将栈指针向下移动将申请一块新的内存，向上移动则会释放这块内存；效率仅次于寄存器。对于Java而言，存储在栈上的对象，需要明确生命周期。 堆，使用的也是RAM空间，用于存放所有Java对象。编译器不关心存储在堆上的对象的存活时间。 常量存储，常量通常直接保存在程序代码中；在某些嵌入式系统里，会保存在只读存储器（ROM）中。 非RAM存储，针对数据不依赖于英语程序是否运行的情况，比如以文件的方式存储在磁盘。 Java基本类型 在Java中，只能通过new在堆上创建对象。但是，基本类型无须使用new来创建，Java是直接创建一个“自动变量”，并在栈上保存它的值。
占用空间大小 基本类型 大小 boolean - char 16位 byte 8位 short 16位 int 32位 long 64位 float 32位 double 64位 void - 上述表格中所有数值类型都是有符号的。 额外强调:boolean类型的空间大小没有明确标出，其对象只能被赋值为true或false。</description></item><item><title>Java访问控制</title><link>https://chenhaoqing.github.io/posts/onjava/java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link><pubDate>Sat, 04 Jun 2022 23:57:25 +0800</pubDate><guid>https://chenhaoqing.github.io/posts/onjava/java%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid><description>访问修饰符 Java提供了3个显式关键字来完成访问控制，即public、private以及protected。
public，表示定义的内容可以被所有人访问 private，表示定义的内容只能被雷的创建者通过该类自身的方法访问，而其他任何人都无法访问 protected，类似于private，区别在于继承的子类可以访问protected成员，但不可以访问private成员 包访问 如果不使用上述访问修饰符，Java会提供一种“默认”访问权限，通常叫作“包访问”。
包访问，一个类可以访问同一个包里的其他类；但是如果从包外部访问这些类的话，它们就像private内容一样不可访问。</description></item><item><title>First Post!</title><link>https://chenhaoqing.github.io/posts/introduction/</link><pubDate>Fri, 13 May 2022 23:16:25 +0800</pubDate><guid>https://chenhaoqing.github.io/posts/introduction/</guid><description>这是依据指引一步步操作完成后，所发出的第一篇博客，在此记录下。</description></item></channel></rss>